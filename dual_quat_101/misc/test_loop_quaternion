. groundtruth
- https://www.andre-gaschler.com/rotationconverter/
  - Euler angle: ZYX type
- https://quaternions.online/
  - Euler angle: ZYX order

void QuaternionOperation::MainLoop()
{
  // assigning the quaternion directly
  Quaterniond q1;
  q1 = CalcSingleQuaternion(-0.0025633, -0.8545912, 0.2848596, 0.4341915);
  ROS_INFO("input, q1:(x,y,z,w)=(%.4lf,%.4lf,%.4lf,%.4lf)", q1.x(), q1.y(), q1.z(), q1.w());

  // converting the quaternion to the Euler angle(3-2-1, ZYX, YPR)
  Vector3d vecEulerQ1;
  vecEulerQ1 = QuaternionOperation::CalcYPREulerAngFromQuaternion(q1);
  ROS_INFO("input, q1:euler(3-2-1):(r,p,y)=(%.4lf,%.4lf,%.4lf)", vecEulerQ1(0) * R2D, vecEulerQ1(1) * R2D,
           vecEulerQ1(2) * R2D);

  ROS_INFO(" ");

  // converting the Euler angle(3-2-1, ZYX, YPR) to the quaternion
  Quaterniond q1CrsCheck;
  q1CrsCheck = CalcQuaternionFromYPREulerAng(vecEulerQ1);
  ROS_INFO("input, q1ROSCrsCheck:(x,y,z,w)=(%.4lf,%.4lf,%.4lf,%.4lf)", q1CrsCheck.x(), q1CrsCheck.y(), q1CrsCheck.z(),
           q1CrsCheck.w());

  ROS_INFO(" ");

  // assigning the quaternion directly
  Quaterniond q2;
  q2 = CalcSingleQuaternion(0.4619398, -0.1913417, 0.4619398, 0.7325378);
  ROS_INFO("input, q2:(x,y,z,w)=(%.4lf,%.4lf,%.4lf,%.4lf)", q2.x(), q2.y(), q2.z(), q2.w());

  // converting the quaternion to the Euler angle(3-2-1, ZYX, YPR)
  Vector3d vecEulerQ2;
  vecEulerQ2 = QuaternionOperation::CalcYPREulerAngFromQuaternion(q2);
  ROS_INFO("input, q1:euler(3-2-1):(r,p,y)=(%.4lf,%.4lf,%.4lf)", vecEulerQ2(0) * R2D, vecEulerQ2(1) * R2D,
           vecEulerQ2(2) * R2D);

  ROS_INFO(" ");

  // converting the Euler angle(3-2-1, ZYX, YPR) to the quaternion
  Quaterniond q2CrsCheck;
  q2CrsCheck = CalcQuaternionFromYPREulerAng(vecEulerQ2);
  ROS_INFO("input, q2ROSCrsCheck:(x,y,z,w)=(%.4lf,%.4lf,%.4lf,%.4lf)", q2CrsCheck.x(), q2CrsCheck.y(), q2CrsCheck.z(),
           q2CrsCheck.w());

  ROS_INFO(" ");

  // calculating addition w.r.t the quaternions
  Quaterniond qAddRes = CalcAddQuaternions(q1, q2);
  ROS_INFO("ouput, add = (x,y,z,w)=(%.4lf,%.4lf,%.4lf,%.4lf)", qAddRes.x(), qAddRes.y(), qAddRes.z(), qAddRes.w());

  ROS_INFO(" ");

  // calculating subtraction w.r.t the quaternions
  Quaterniond qSubRes = CalcSubQuaternions(q1, q2);
  ROS_INFO("ouput, sub = (x,y,z,w)=(%.4lf,%.4lf,%.4lf,%.4lf)", qSubRes.x(), qSubRes.y(), qSubRes.z(), qSubRes.w());

  ROS_INFO(" ");

  // calculating the conjugate quaternion
  Quaterniond q1ConjRes = CalcConjugateQuaternion(q1);
  ROS_INFO("ouput, conj,q1 = (x,y,z,w)=(%.4lf,%.4lf,%.4lf,%.4lf)", q1ConjRes.x(), q1ConjRes.y(), q1ConjRes.z(),
           q1ConjRes.w());

  ROS_INFO(" ");

  // calculating the conjugate quaternion
  Quaterniond q2ConjRes = CalcConjugateQuaternion(q2);
  ROS_INFO("ouput, conj,q2 = (x,y,z,w)=(%.4lf,%.4lf,%.4lf,%.4lf)", q2ConjRes.x(), q2ConjRes.y(), q2ConjRes.z(),
           q2ConjRes.w());

  ROS_INFO(" ");

  // calculating the quaternion multiplication
  Quaterniond qMulRes = CalcMultiplyQuaternions(q1, q2);
  ROS_INFO("ouput, mul = (x,y,z,w)=(%.4lf,%.4lf,%.4lf,%.4lf)", qMulRes.x(), qMulRes.y(), qMulRes.z(), qMulRes.w());

  ROS_INFO(" ");

  // 3x3 matrix
  ROS_INFO("output, q1, skew matrix by quaternion");
  cout << CalcQuaternionSkewMatrix(q1) << endl;

  ROS_INFO(" ");

  // 3x3 matrix
  ROS_INFO("output, q1, quaternion rotation matrix");
  cout << CalcQuaternionRotationMatrix(q1) << endl;

  ROS_INFO(" ");

  // calculating the axis-angle from the quaternion
  Vector4d axisInfoQ1;
  axisInfoQ1 = CalcAxisAngFromQuaternion(q1);
  ROS_INFO("ouput, axisInfo, q1 = (x,y,z,theta)=(%.4lf,%.4lf,%.4lf,%.4lf)", axisInfoQ1(0), axisInfoQ1(1), axisInfoQ1(2),
           axisInfoQ1(3) * R2D);

  ROS_INFO(" ");

  // calculating the axis with the magnitude from the quaternion
  Vector3d normAxisQ1;
  normAxisQ1 = CalcAxisMagFromQuaternion(CalcAxisAngFromQuaternion(q1));
  ROS_INFO("ouput, axisNorm, q1 = (x,y,z)=(%.4lf,%.4lf,%.4lf)", normAxisQ1(0) * R2D, normAxisQ1(1) * R2D,
           normAxisQ1(2) * R2D);

  ROS_INFO(" ");

  // 3x3 matrix
  ROS_INFO("output, q2, skew matrix by quaternion");
  cout << CalcQuaternionSkewMatrix(q2) << endl;

  ROS_INFO(" ");

  // 3x3 matrix
  ROS_INFO("output, q2, quaternion rotation matrix");
  cout << CalcQuaternionRotationMatrix(q2) << endl;

  ROS_INFO(" ");

  // calculating the axis-angle from the quaternion
  Vector4d axisInfoQ2;
  axisInfoQ2 = CalcAxisAngFromQuaternion(q2);
  ROS_INFO("ouput, axisInfo, q2 = (x,y,z,theta)=(%.4lf,%.4lf,%.4lf,%.4lf)", axisInfoQ2(0), axisInfoQ2(1), axisInfoQ2(2),
           axisInfoQ2(3) * R2D);

  ROS_INFO(" ");

  // calculating the axis with the magnitude from the quaternion
  Vector3d normAxisQ2;
  normAxisQ2 = CalcAxisMagFromQuaternion(CalcAxisAngFromQuaternion(q2));
  ROS_INFO("ouput, axisNorm, q2 = (x,y,z)=(%.4lf,%.4lf,%.4lf)", normAxisQ2(0) * R2D, normAxisQ2(1) * R2D,
           normAxisQ2(2) * R2D);
}

// for main loop

// Main loop.
// while (ok())
// {
//   quatOper.MainLoop();

//   spinOnce();
//   loopRate.sleep();
// }


void QuaternionOperation::MainLoop()
{
  Vector3d u;
  u(0) = 1.0;
  u(1) = 2.0;
  u(2) = 3.0;

  Vector3d v;
  v(0) = 3.0;
  v(1) = 2.0;
  v(2) = 1.0;

  Vector3d uvAddEigen;
  Vector3d uvSubEigen;
  double uvDotEigen;
  Vector3d uvCrossEigen;  
  uvAddEigen = u + v;
  uvSubEigen = u - v;
  uvDotEigen = u.dot(v);
  uvCrossEigen = u.cross(v);

  Vector3d uvAddFunc;
  Vector3d uvSubFunc;
  double uvDotFunc;
  Vector3d uvCrossFunc;    
  uvAddFunc = CalcVec3dAdd(u, v);  
  uvSubFunc = CalcVec3dSub(u, v);
  uvDotFunc = CalcVec3dDot(u, v);
  uvCrossFunc = CalcVec3dCross(u, v);

  ROS_INFO("uvAddEigen:(%.4lf, %.4lf, %.4lf)", uvAddEigen(0), uvAddEigen(1), uvAddEigen(2));
  ROS_INFO("uvAddFunc:(%.4lf, %.4lf, %.4lf)", uvAddFunc(0), uvAddFunc(1), uvAddFunc(2));
  ROS_INFO(" ");

  ROS_INFO("uvSubEigen:(%.4lf, %.4lf, %.4lf)", uvSubEigen(0), uvSubEigen(1), uvSubEigen(2));
  ROS_INFO("uvSubFunc:(%.4lf, %.4lf, %.4lf)", uvSubFunc(0), uvSubFunc(1), uvSubFunc(2));
  ROS_INFO(" ");

  ROS_INFO("uvDotEigen:(%.4lf)", uvDotEigen);
  ROS_INFO("uvDotFunc:(%.4lf)", uvDotFunc);
  ROS_INFO(" ");

  ROS_INFO("uvCrossEigen:(%.4lf, %.4lf, %.4lf)", uvCrossEigen(0), uvCrossEigen(1), uvCrossEigen(2));
  ROS_INFO("uvCrossFunc:(%.4lf, %.4lf, %.4lf)", uvCrossFunc(0), uvCrossFunc(1), uvCrossFunc(2));
  ROS_INFO(" ");
}


void QuaternionOperation::MainLoop()
{
  Matrix3d matP;
  matP(0, 0) = 5.0;
  matP(0, 1) = 3.4;
  matP(0, 2) = 3.0;
  matP(1, 0) = 2.0;
  matP(1, 1) = 5.4;
  matP(1, 2) = 6.0;
  matP(2, 0) = 7.0;
  matP(2, 1) = 8.2;
  matP(2, 2) = 9.0;

  cout << "matP=" << endl;
  cout << matP << endl;

  cout << "matI=" << endl;
  cout << CalcMat3dIdentity() << endl;  

  cout << "matP.determinant=" << matP.determinant() << endl;
  ROS_INFO("matP.determinant:%lf", CalcMat3dDeterminant(matP));  
}

void QuaternionOperation::MainLoop()
{
  Quaterniond q;
  q.x() = 0.2710782;
  q.y() = 0.0090755;
  q.z() = 0.3503061;
  q.w() = 0.8965043;

  ROS_INFO("input, q = (x,y,z,w)=(%.4lf,%.4lf,%.4lf,%.4lf)", q.x(), q.y(), q.z(), q.w());

  // 3x3 matrix
  Matrix3d matQatt;
  matQatt = CalcQuaternionRotationMatrix(q);
  ROS_INFO("output, q, quaternion rotation matrix");
  cout << matQatt << endl;

  Quaterniond qConvFromMat(matQatt);
  ROS_INFO("output, qConvFromMat = (x,y,z,w)=(%.4lf,%.4lf,%.4lf,%.4lf)", qConvFromMat.x(), qConvFromMat.y(),
           qConvFromMat.z(), qConvFromMat.w());
}

void QuaternionOperation::MainLoop()
{
  Quaterniond q;
  q.x() = 0.2710782;
  q.y() = 0.0090755;
  q.z() = 0.3503061;
  q.w() = 0.8965043;

  ROS_INFO("input, q = (x,y,z,w)=(%.4lf,%.4lf,%.4lf,%.4lf)", q.x(), q.y(), q.z(), q.w());

  double qNormEigen = q.norm();
  ROS_INFO("output, qNormEigen:%.4lf", qNormEigen);

  double qNormFunc = ((q.x()) * (q.x())) + ((q.y()) * (q.y())) + ((q.z()) * (q.z())) + ((q.w()) * (q.w()));
  ROS_INFO("output, qNormFunc:%.4lf", qNormFunc);
}